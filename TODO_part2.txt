Kom ihåg
--------
¤ Lazy && and ||

TODO
----
¤ Flytta över ansvaret i jlc till Main, använd System.Process (funktionen
  callCommand :: String -> IO() verkar användbar). 
  Exempel i Windows:
    import System.Process
    main :: IO ()
    main = do
        callCommand "echo \"hej\""
        callCommand "echo \"hallo\""
        callCommand "echo \"hi\""
  Ide: Behåll dock filen jlc och pipe:a anropet från testsuiten genom den till 
  Main som  partA. Ha eventuellt   kompilleringen av main.o och genererandet av 
  a.out i jlc.
  
¤ Få testsuiten att köra.

¤ Skriv om Main så den blir snyggare. Kan göra så att check returnerar IO () eller
  använda en monad.
  
¤ Fixa compileStms så den genererar ett unreachable i core026.
  Ide: Skriv unreachable även om det inte är sista stm:et för while-true. 
       Returnera sedan utan att göra rekursivt anrop?
  case (ss, s) of
    (_, (SWhile (EType TBool (ELit (LBool "true"))) _)) -> emitText "unreachable"

¤ Skriv om EAnd och EOr, se nedan för tips.

¤ Skriv om ENot: kan modelleras genom att returnera e == false (med icmp). 
  Använd BCmp-instruktionen.
  
¤ Ha med runtime.bc (obs: den kompillerade filen) i tar-bollen. Inte runtime.ll?

TODO lägre prio
---------------
¤ Skriv kommentarer i alla nya filer.
¤ Skriv om alpharen med statemonad?


Frågor
------
¤ Hur sparar vi namnet på testfilen i jlc? Vi behöver det sedan för att 
  kompillera llvm-filen, länka dem osv.
  A: Gör det från Haskell istället, m h a System.Process
     $@ plockar ut första argumentet i anropet.
  
¤ Ska .bc, main.bc, main.o och a.out hamna i samma mapp som testfilerna
  (/graderTestSuite/good)? Hur säger vi till gcc att lägga a.out där isf?
  A: Bara .ll oc .bc i den mappen, resten hos jlc
  
¤ Vi får en konstig #test.ll#-fil med nuvarande jlc.
  A: Känner inte igen, men gör nog inget
  
¤ Behöver vi ha med \0A i de globala strängarna? Vad är den till för? llvm-as
  klagar om vi har med den och har längd +2
  A: det är newline, behöver inte ha med den
  
¤ Testfilen core026: Är den verkligen ok? Den avslutas ju inte med en return.
  Är det för att den har en while-true (och det inte finns ngt break i språket)
  och den aldrig kommer lämna loopen som vi inte bryr oss om det?
  A: den är bra, använd unreachable efter while-true
  
¤ Är det ok att använda LLVMs funktioner and och or (är de lazy?) eller får vi 
  bara använda de funktioner som finns på listan från lec3?
        "Basic JavaLette will only need the following instructions:
            • Terminator instructions: ret and br
            • Arithmetic operations:
                • For integers add, sub, mul, sdiv and srem
                • For doubles fadd, fsub, fmul and fdiv
            • Memory access: alloca, load, getelementptr and store
            • Other: icmp, fcmp and call
        Some of the extensions will need more instructions."
  A: De är nog inte lazy, så ite ok. Vi an lösa det antingen genom att codegen:a 
     booleanska uttryck separat eller att göra som nedan men generera först 
     minne för ny variabel på stacken och sätt den till olika värden i de olika
     brancherna.
  
  Idé till lazy AND:
      compileExp(EAnd e1 e2) = do
        vE1 <- compileExp e1
        emit $ Br2 vE1 lTrue lFalse
        lTrue:
            vE2 <- compileExp e2
            (return vE2)
            emit $ Br1 lEnd
        lFalse:
            (return "false")
            emit $ Br1 lEnd
        lEnd:
    Hur kan vi komma runt att ha två return?
    
    
    
